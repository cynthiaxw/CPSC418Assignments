Name:Xi Wang
UCID:30057535

•File list:
	-secureFile.java
	 This is the source code of encryption and message authentication program.

	-decryptFile.java
	 This is the source code of decryption and digest verification program.

	-Client.java
	 Client sends an authenticated and encrypted file to a server. Encrypt both the messages and the means for authentication.

	-Server.java
	 Server decrypt the file, check the integrity of the file content, and write the file content to the destination file specified by the client.

	-ServerThread.java
	 Containing a class for the thread to deal with clients who connect to the Server

	-README.txt
	 Description.


•How to compile: 
	Use command line tool to open this folder.
	Type “javac secureFile.java” and enter.
	Type “javac decryptFile.java” and enter.
	Type “javac Client.java” and enter.
	Type “javac Server.java” and enter.
	Type “javac ServerThread.java” and enter.

•How to test:
	-java Server portnumber (e.g. java Client 7777) or: java Server portnumber debug
	-java Client hostname portnumber (e.g. java Client localhost 7777) or: java Client hostname portnumber debug
	-In Client window, there will be a request to enter key(seed), source file name and destination file name
	-In Server window, there will be a request to enter a key(seed).
	-There will be a message displayed for success or failure.


•What is implemented:
	-Client program is to transfer a user-specified file to the server while providing confidentiality and data integrity.
	-Client program is to encrypt both the messages and the means for authentication.
	-The server is to decrypt the file, check the integrity of the file content, and write the file content to the destination file specified by the client.
	-Server is to send an acknowledgement to the client reporting success if the file was correctly decrypted.
	-The client should exit after receiving the acknowledgement.

•Description of my file transfer protocol:
	-Description of all protocol messages:
	 Plaintext is encrypted by Client. The destination file name, length of the source file in bytes, and the source file contents (encrypted and integrity-protected) are then transferred to the server.
	 I used DataInputStream and DataOutputStream for message sending and receiving.

	-How encryption and data integrity are employed and how I prevented the attacks on confidentiality and data integrity mentioned above:
	 Use message digest.The digest is generated by the message(original plaintext), using the byte[] sha1_hash(byte[] input_data) method. It’s 20 bytes. In encryption: the generated digest is concatenated to the end of the plaintext. I used System.arraycopy() method. In decryption: I slice the last 20 bytes from the decrypted massage to separate it from plaintext, using Arrays.copyOfRange() method. To verify if the cipher file has been modified, I use sha1_hash() method(same as when encrypt) to generate the expected digest. And then compare it with the actual digest(mentioned above). If they are the same, then the file has not been changed. Because the key generation is depended on the seed, so it will generate the same key when we use the correct seed to decrypt a file.



•Reference: Client.java, Server.java and ServerThread.java form the course webpage as well as my own codes for assignment1.	
